/*
 * $Id: RC4_HMAC.java,v 1.3 2008-08-25 19:02:51 bofriis Exp $
 */
package dk.appliedcrypto.spnego;

import java.io.UnsupportedEncodingException;
import java.security.MessageDigest;
import java.util.Random;

/**
 * 
 * <pre>
 * struct EDATA { 
 * 	struct HEADER { 
 * 		OCTET Checksum[16]; 
 * 		OCTET Confounder[8]; 
 * 	} Header; 
 * 	OCTET Data[0]; 
 * } edata;
 * </pre>
 * 
 * <p>
 * <small>SPNEGO SSO<br>
 * Copyright(c), Applied Crypto Aps, All rights reserved </small>
 * </p>
 * @author Jens Bo Friis, bofriis@gmail.com
 * @see RFC 4757
 */
public class RC4_HMAC extends EType {

	static class HEADER {
		byte[] checksum = new byte[16];

		byte[] confounder = new byte[8];

		HEADER() {
		}

		HEADER(byte[] header) {
			System.arraycopy(header, 0, checksum, 0, checksum.length);
			System.arraycopy(header, checksum.length, confounder, 0, confounder.length);
		}

		byte[] getBytes() {
			byte[] header = new byte[checksum.length + confounder.length];
			System.arraycopy(checksum, 0, header, 0, checksum.length);
			System.arraycopy(confounder, 0, header, checksum.length, confounder.length);
			return header;
		}

		int getLen() {
			return checksum.length + confounder.length;
		}

		public String toString() {
			return "checksum:" + HexDump.xdump(checksum) + "confounder:" + HexDump.xdump(confounder);
		}
	}

	static Random rnd = new Random(System.currentTimeMillis());

	public static byte[] nonce(int i) {
		byte[] bytes = new byte[i];
		rnd.nextBytes(bytes);
		return bytes;
	}

	static class EDATA {
		HEADER header;

		byte[] data;

		EDATA() {
			header = new HEADER();
		}

		EDATA(byte[] bytes) {
			header = new HEADER(bytes);
			data = new byte[bytes.length - header.getLen()];
			System.arraycopy(bytes, header.getLen(), data, 0, data.length);
		}

		/*
		 * return checksum | confounder | data
		 */
		byte[] getBytes() {
			byte[] bytes = new byte[header.getLen() + data.length];
			System.arraycopy(header.checksum, 0, bytes, 0, header.checksum.length);
			System.arraycopy(header.confounder, 0, bytes, header.checksum.length, header.confounder.length);
			System.arraycopy(data, 0, bytes, header.checksum.length + header.confounder.length, data.length);
			return bytes;
		}

		public String toString() {
			return header.toString();
		}
	}

	public RC4_HMAC() {
		try {
			encType = EType.ETYPE_RC4_HMAC;
			/* "RC4-HMAC" */
			String msg = "RC4-HMAC";
			encTypeName = msg;
		} catch (NullPointerException e) {
			throw e;
		}
	}

	/**
	 * The RC4-HMAC String to key function is defined as follow:
	 * <p>
	 * 
	 * <code>String2Key(password)</code>
	 * <p>
	 * 
	 * K = MD4(UNICODE(password))
	 * <p>
	 * The RC4-HMAC keys are generated by using the Windows UNICODE version of
	 * the password. Each Windows UNICODE character is encoded in little-endian
	 * format of 2 octets each. Then performing an MD4 [6] hash operation on
	 * just the UNICODE characters of the password (not including the
	 * terminating zero octets).
	 * <p>
	 * For an account with a password of "foo", this String2Key("foo") will
	 * return:
	 * <p>
	 * <code>
	 0xac, 0x8e, 0x65, 0x7f, 0x83, 0xdf, 0x82, 0xbe, 
	 0xea, 0x5d, 0x43, 0xbd, 0xaf, 0x78, 0x00, 0xcc</code>
	 * 
	 * @see RFC4757
	 * @param password
	 * @return
	 */
	public static byte[] String2Key(char[] password) {
		try {
			String pw = new String(password);
			byte[] secret;
			secret = pw.getBytes("UnicodeLittleUnmarked");
			secret = MD4.mdfour(secret);
			return secret;
		} catch (UnsupportedEncodingException e) {
			return null;
		}
	}

	public static byte[] bytes2Key(byte[] bytes) throws Exception {
		byte[] secret;
		secret = MD4.mdfour(bytes);
		return secret;
	}

	public static String PasswordFromUnicode(byte[] bytes) throws Exception {
		String pw = new String(bytes, "UnicodeLittleUnmarked");
		return pw;
	}

	private static byte[] HMAC(byte[] key, byte[] data) throws KrbException {
		try {
			return HMACMD5.hmacMD5(data, key);
		} catch (KrbException e) {
			throw e;
		}
	}

	private static byte[] MD5(byte[] secret) throws Exception {
		MessageDigest messagedigest = MessageDigest.getInstance("MD5");
		messagedigest.reset();
		messagedigest.update(secret);
		secret = messagedigest.digest();
		return secret;
	}

	/**
	 * Stream cipher RC4.
	 * 
	 * @see draft-kaukonen-cipher-arcfour-03.txt
	 * @return
	 */
	private static byte[] RC4(byte[] key, byte[] data, boolean fEncrypt) {
		try {
			RC4 rc4 = new RC4();
			rc4.setKey(key);
			if (fEncrypt)
				return rc4.encrypt(data);
			else
				return rc4.decrypt(data);
		} catch (RuntimeException e) {
			throw e;
		}
	}

	/* "fortybits" */
	String fortybits = "fortybits";

//	private byte[] L40 = fortybits.getBytes();

	/* "signaturekey" */
	String signaturekey = "signaturekey";

//	private byte[] SK = signaturekey.getBytes();

	// static byte[] ENCRYPT (byte[] K, boolean fRC4_EXP, byte[] T, byte[] data,
	// int data_len, byte[] edata, int edata_len)
	// {
	// if (fRC4_EXP){
	// *((DWORD *)(L40+10)) = T;
	// HMAC (K, L40, 10 + 4, K1);
	// }else{
	// HMAC (K, T, 4, K1);
	// }
	// memcpy (K2, K1, 16);
	// if (fRC4_EXP) memset (K1+7, 0xAB, 9);
	// add_8_random_bytes(data, data_len, conf_plus_data);
	// HMAC (K2, conf_plus_data, 8 + data_len, checksum);
	// HMAC (K1, checksum, 16, K3);
	// RC4(K3, conf_plus_data, 8 + data_len, edata + 16);
	// memcpy (edata, checksum, 16);
	// edata_len = 16 + 8 + data_len;
	// }

	public static byte[] writeLittleEndianFourBytes(int num) {
		byte[] bytes = new byte[4];
		bytes[3] = (byte) ((num & 0xff000000) >> 24 & 0xff);
		bytes[2] = (byte) ((num & 0x00ff0000) >> 16 & 0xff);
		bytes[1] = (byte) ((num & 0x0000ff00) >> 8 & 0xff);
		bytes[0] = (byte) (num & 0xff);
		return bytes;
	}

	// private static byte[] getSalt(int i) {
	// int j = arcfour_translate_usage(i);
	// byte abyte0[] = new byte[4];
	// abyte0[0] = (byte) (j & 0xff);
	// abyte0[1] = (byte) (j >> 8 & 0xff);
	// abyte0[2] = (byte) (j >> 16 & 0xff);
	// abyte0[3] = (byte) (j >> 24 & 0xff);
	// return abyte0;
	// }

	private static byte[] encrypt(byte[] K, int messageType, byte[] data) throws KrbException {
		messageType = map2rc4hmacMsgTypes(messageType);
		EDATA edata = new EDATA();

		byte[] T = writeLittleEndianFourBytes(messageType);
		byte[] K1 = HMAC(K, T);

		byte[] K2 = new byte[K1.length];
		System.arraycopy(K1, 0, K2, 0, K2.length);

		edata.data = data;

		edata.header.confounder = nonce(8);

		byte[] cdata = concat(edata.header.confounder, edata.data);
		edata.header.checksum = HMAC(K2, cdata);

		byte[] K3 = HMAC(K1, edata.header.checksum);

		byte[] dconfounder = RC4(K3, edata.header.confounder, false);

		edata.header.confounder = dconfounder;

		// System.out.println(HexDump.xdump(dconfounder));
		// decrypted confounder should match the first 8 bytes in the
		// decrypted
		// data blob
		// this is the check!
		byte[] ddata = RC4(K3, cdata, false);
		byte[] ddata1 = new byte[ddata.length - 8];
		System.arraycopy(ddata, 8, ddata1, 0, ddata1.length);

		edata.data = ddata1;

		return edata.getBytes();
	}

	/**
	 * These encryption types use key derivation. With each message, the message
	 * type (T) is used as a component of the keying material. The following
	 * table summarizes the different key derivation values used in the various
	 * operations. Note that these differ from the key
	 * 
	 * derivations used in other Kerberos encryption types. T = the message
	 * type, encoded as a little-endian four-byte integer.
	 * 
	 * <ul>
	 * <li>1 AS-REQ PA-ENC-TIMESTAMP padata timestamp, encrypted with the client
	 * key (T=1)
	 * 
	 * <li>2 AS-REP Ticket and TGS-REP Ticket (includes TGS session key or
	 * application session key), encrypted with the service key (T=2)
	 * 
	 * <li>3. AS-REP encrypted part (includes TGS session key or application
	 * session key), encrypted with the client key (T=8)
	 * 
	 * <li>4 TGS-REQ KDC-REQ-BODY AuthorizationData, encrypted with the TGS
	 * session key (T=4)
	 * 
	 * <li>5 TGS-REQ KDC-REQ-BODY AuthorizationData, encrypted with the TGS
	 * authenticator subkey (T=5)
	 * 
	 * <li>6 TGS-REQ PA-TGS-REQ padata AP-REQ Authenticator cksum, keyed with
	 * the TGS session key (T=6)
	 * 
	 * <li>7 TGS-REQ PA-TGS-REQ padata AP-REQ Authenticator (includes TGS
	 * authenticator subkey), encrypted with the TGS session key T=7)
	 * 
	 * <li>8. TGS-REP encrypted part (includes application session key),
	 * encrypted with the TGS session key (T=8)
	 * 
	 * <li>9 TGS-REP encrypted part (includes application session key),
	 * encrypted with the TGS authenticator subkey (T=8)
	 * 
	 * <li>10 AP-REQ Authenticator cksum, keyed with the application session key
	 * (T=10)
	 * 
	 * <li>11 AP-REQ Authenticator (includes application authenticator subkey),
	 * encrypted with the application session key (T=11)
	 * 
	 * <li>12. AP-REP encrypted part (includes application session subkey),
	 * encrypted with the application session key (T=12)
	 * 
	 * <li>13 KRB-PRIV encrypted part, encrypted with a key chosen by the
	 * application. Also for data encrypted with GSS Wrap (T=13)
	 * 
	 * <li>14. KRB-CRED encrypted part, encrypted with a key chosen by the
	 * application (T=14)
	 * 
	 * <li>15 KRB-SAFE cksum, keyed with a key chosen by the application. Also
	 * for data signed in GSS MIC (T=15)
	 * 
	 * </ul>
	 * Relative to RFC-1964 key uses:
	 * <ul>
	 * <li> T = 0 in the generation of sequence number for the MIC token
	 * 
	 * <li> T = 0 in the generation of sequence number for the WRAP token
	 * 
	 * <li> T = 0 in the generation of encrypted data for the WRAPPED token
	 * </ul>
	 * All strings in this document are ASCII unless otherwise specified. The
	 * lengths of ASCII-encoded character strings include the trailing
	 * terminator character (0). The concat(a,b,c,...) function will return the
	 * logical concatenation (left to right) of the values of the arguments. The
	 * nonce(n) function returns a pseudo-random number of "n" octets.
	 * 
	 * @see http://www.apps.ietf.org/rfc/rfc4757.html
	 * 
	 * @param msgtype
	 * @return
	 */
	private static int map2rc4hmacMsgTypes(int msgtype) {
		if (msgtype == EType.KU_ENC_AS_REP_PART)
			return 8;
		if (msgtype == EType.KU_ENC_TGS_REP_PART_SUBKEY)
			return 8;
		return msgtype;
	}

	private static byte[] concat(byte[] ba1, byte[] ba2) {
		byte[] bytes = new byte[ba1.length + ba2.length];
		System.arraycopy(ba1, 0, bytes, 0, ba1.length);
		System.arraycopy(ba2, 0, bytes, ba1.length, ba2.length);
		return bytes;
	}

	/**
	 * <pre>
	 * struct EDATA { 
	 * 	struct HEADER { 
	 * 		OCTET Checksum[16]; 
	 * 		OCTET Confounder[8]; 
	 * 	} Header; 
	 * 	OCTET Data[0]; 
	 * } edata;
	 * </pre>
	 * 
	 * @param K
	 *            key, 16 bytes
	 * @param messageType
	 *            (typically =2, AP REP)
	 * @param edata
	 *            encrypted bytes
	 * @return decrypted bytes ASN.1 <code>EncTicketPart</code>
	 * @throws Exception
	 */
	private static byte[] decrypt(byte[] K, int messageType, byte[] edata) throws KrbException {
		try {
			messageType = map2rc4hmacMsgTypes(messageType);
			byte[] checksum = new byte[16];
			byte[] confounder = new byte[8];
			byte[] data = new byte[edata.length - checksum.length];

			// | 16bytes checksum | 8 bytes confounder | rest is data... |

			EDATA encdata = new EDATA(edata);

			System.arraycopy(edata, 0, checksum, 0, checksum.length);
			System.arraycopy(edata, checksum.length, confounder, 0, confounder.length);

			// System.arraycopy(edata, 0, confounder, 0, confounder.length);
			// System.arraycopy(edata, confounder.length, checksum, 0,
			// checksum.length);

			/*
			 * data = confounder | data
			 */
			System.arraycopy(edata, checksum.length, data, 0, data.length);

			byte[] T = writeLittleEndianFourBytes(messageType);
			byte[] K1 = HMAC(K, T);

			byte[] K2 = new byte[K1.length];
			System.arraycopy(K1, 0, K2, 0, K2.length);

			byte[] K3 = HMAC(K1, checksum);

			byte[] dconfounder = RC4(K3, confounder, false);

			// System.out.println(HexDump.xdump(dconfounder));
			// decrypted confounder should match the first 8 bytes in the
			// decrypted
			// data blob
			// this is the check!
			byte[] ddata = RC4(K3, data, false);

			/* "integrity check error, check encryption key" */
			String msg = "integrity check error, check encryption key";

			for (int i = 0; i < dconfounder.length; i++)
				if (dconfounder[i] != ddata[i])
					throw new KrbException(KrbException.KRB_GENERAL_ERROR, msg);

			/*
			 * // verify generated and received checksums checksum = HMAC (K2,
			 * concat(edata.Confounder, edata.Data)); if (checksum !=
			 * edata.Checksum) printf("CHECKSUM ERROR  !!!!!!\n");
			 */
			byte[] ddata1 = new byte[ddata.length - 8];
			System.arraycopy(ddata, 8, ddata1, 0, ddata1.length);

			EDATA edata1 = new EDATA();
			edata1.header.confounder = dconfounder;
			edata1.data = ddata;
			byte[] checksum1 = HMAC(K2, concat(edata1.header.confounder, ddata1));

			 for (int i=0; i<checksum.length; i++)
			 if (checksum[i]!=checksum1[i])
			 throw new KrbException(KrbException.KRB_GENERAL_ERROR,
			 "Checksum error, probably wrong encryption key");

			return ddata1;
		} catch (KrbException e) {
			throw e;
		}
	}

	// private static int arcfour_translate_usage(int i) {
	// switch (i) {
	// case 3: // '\003'
	// return 8;
	//
	// case 9: // '\t'
	// return 8;
	//
	// case 23: // '\027'
	// return 13;
	// }
	// return i;
	// }

	// private static byte[] stripASN1Bytes(byte[] data) throws IOException {
	// System.out.println("decrypted bytes:" + HexDump.xdump(data));
	// DerInputStream dis = new DerInputStream(data);
	// DerValue dv = dis.getDerValue();
	// System.out.println("tag:" + dv.getTag());
	// byte[] bytes = dv.encoded();
	// System.out.println("value#" + bytes.length);
	// // byte[] bytes = null;
	// if ((data[1] & 0xFF) < 128) {
	// bytes = new byte[data[1] + 2];
	// System.arraycopy(data, 0, bytes, 0, data[1] + 2);
	// } else {
	// if ((data[1] & 0xFF) > 128) {
	// int len = (int) (data[1] & (byte) 0x7F);
	// int result = 0;
	// for (int i = 0; i < len; i++) {
	// result |= (data[i + 2] & 0xFF) << (8 * (len - i - 1));
	// }
	// bytes = new byte[result + len + 2];
	// System.arraycopy(data, 0, bytes, 0, result + len + 2);
	// }
	// }
	// return bytes;
	// }

	/**
	 * @param byte[] K - is the Key
	 * @param byte[] T - the message type, encoded as a little-endian four byte
	 *        integer
	 * @param byte[] data
	 * 
	 * @return byte[] checsum
	 */
	private static byte[] CHKSUM(byte[] K, byte[] T, byte[] data) throws Exception {
		try {
			/* "signaturekey" */
			String signaturekey = "signaturekey";

			byte[] Ksign = HMAC(K, signaturekey.getBytes()); // includes zero
			// octet at end
			byte[] tmp = MD5(concat(T, data));
			byte[] CHKSUM = HMAC(Ksign, tmp);
			return CHKSUM;
		} catch (Exception e) {
			throw e;
		}
	}

	private static boolean equals(byte[] a, byte[] b) {
		if (a.length != b.length)
			return false;
		for (int i = 0; i < a.length; i++)
			if (a[i] != b[i])
				return false;
		return true;
	}

	public byte[] encrypt(EncryptionKey key, int messageType, byte[] plaintext) throws KrbException {
		try {
			// check if key matches this encType
			if (key.getKeyType() != this.encType)
				return null; // provided key does not match encryption
			// algorithm
			return encrypt(key.getKeyValue(), messageType, plaintext);
		} catch (KrbException e) {
			throw e;
		}
	}

	public byte[] decrypt(EncryptionKey key, int messageType, byte[] cipher) throws KrbException {
		try {
			// check if key matches this encType
			if (key.getKeyType() != this.encType)
				return null; // provided key does not match encryption
			// algorithm
			return decrypt(key.getKeyValue(), messageType, cipher);
		} catch (KrbException e) {
			throw e;
		}
	}
}
